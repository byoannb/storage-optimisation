---
title: "projet_algo"
format: html
editor: visual
---

```{r}
mem = sample(100:1000, size=5, replace=TRUE)
l = sample(1:100, size=25, replace=TRUE)
jeux = sort(l, decreasing = TRUE)
mem = sort(mem, decreasing = TRUE)

mat = matrix(0, nrow = length(mem), ncol = length(jeux))

print(jeux)
cat('\n')
print(mem)
```

```{r}
storage_opti <- function(storages, games){
  
  games = sort(games, decreasing = TRUE)
  storages = sort(storages, decreasing = TRUE)
  
  i_mem = 1
  j_jeu = 1
  mat = matrix(0, nrow = length(storages), ncol = length(games))
  colnames(mat) = games
  rownames(mat) = storages
  
  while(length(games) != 0 && i_mem <= length(storages) && j_jeu <= length(games)){
    if (storages[i_mem] - games[j_jeu] >= 0){
        storages[i_mem] = storages[i_mem] - games[j_jeu]
        mat[i_mem, j_jeu] = 1
        j_jeu = j_jeu + 1
    }
    else {
      i_mem = i_mem + 1
    }
  }
  cat(sum(rowSums(mat) != 0), "out of", length(storages), "storage facilities were used \n")
  cat(sum(colSums(mat)), "out of", length(games), "games could be stored")
  return(mat)
}
```

```{r}
mem = sample(1:5000, size=3, replace=FALSE)
jeux = sample(1:100, size=10, replace=TRUE)
```

```{r}
algo <- function(mem, jeux){
  p = length(mem)
  n = length(jeux)
  
  max = 0
  vect_max = c()
  vect <- as.matrix(expand.grid(rep(list(0:p), n)))
  mat = matrix(0, nrow = p, ncol = n)
  
  mem_count = matrix(0, ncol = p)
  
  for (j in 1:dim(vect)[1]){
    for (i in 1:length(vect[j,])) {
      if (vect[j,i] == 0){
        next
      }
      else{
        mat[vect[j,i], i] <- 1
        mem_count[vect[j,i]] = mem_count[vect[j,i]] + jeux[i]
      }
    }
    if (all(mem_count <= mem)){
      if (sum(rowSums(mat)) > max){
        vect_max = vect[j,]
        max = sum(rowSums(mat))
      }
    }
  }
  
  return(list(max=max, vect_max=vect_max))
}

algo(mem, jeux)
```

# Version 2

```{r}
memoire_exact <- function(jeux, taille_memoire) {
  # Fonction pour générer toutes les permutations
  generate_permutations <- function(elements) {
    if (length(elements) <= 1) {
      return(list(elements))
    } else {
      perms <- list()
      for (i in 1:length(elements)) {
        current_element <- elements[i]
        remaining_elements <- elements[-i]
        sub_perms <- generate_permutations(remaining_elements)
        for (perm in sub_perms) {
          perms <- c(perms, list(c(current_element, perm)))
        }
      }
      return(perms)
    }
  }
  
  # Générer toutes les permutations possibles des jeux
  permutations <- generate_permutations(jeux)
  best_bins <- list()
  
  memoire_minimale <- Inf  # Initialisation à une valeur infinie
  
  # Pour chaque permutation
  for (permutation in permutations) {
    bins <- list()
    memoires <- rep(taille_memoire, length(jeux))  # Initialise toutes les mémoires avec la même taille
    nombre_memoires <- 0
    
    # Essayer de placer chaque jeu dans une mémoire
    for (jeu in permutation) {
      for (i in 1:length(memoires)) {
        if (jeu <= memoires[i]) {
          print(i)
          memoires[i] <- memoires[i] - jeu
          bins[[i]] <- c(bins[[i]], game)
          break
        }
      }
    }
    
    # Calculer le nombre de mémoires utilisées
    nombre_memoires <- sum(taille_memoire - memoires > 0)
    
    # Mettre à jour le nombre minimal de mémoires nécessaires
    if (nombre_memoires < memoire_minimale){
      memoire_minimale <- min(memoire_minimale, nombre_memoires)
      best_bins = bins
    }
    
  }
  
  return(list(memoire_minimale = memoire_minimale, bins = best_bins))
}
```

```{r}
memoire_exact <- function(jeux, taille_memoire) {

  # Fonction pour générer toutes les permutations
  generate_permutations <- function(elements) {
    if (length(elements) <= 1) {
      return(list(elements))
    } else {
      perms <- list()
      for (i in 1:length(elements)) {
        current_element <- elements[i]
        remaining_elements <- elements[-i]
        sub_perms <- generate_permutations(remaining_elements)
        for (perm in sub_perms) {
          perms <- c(perms, list(c(current_element, perm)))
        }
      }
      return(perms)
    }
  }

  # Générer toutes les permutations possibles des jeux
  permutations <- generate_permutations(jeux)
  best_bins <- list()

  memoire_minimale <- Inf  # Initialisation à une valeur infinie

  # Pour chaque permutation
  for (permutation in permutations) {
    bins <- list()
    memoires <- rep(taille_memoire, length(jeux))  # Initialise toutes les mémoires avec la même taille
    nombre_memoires <- 0

    # Essayer de placer chaque jeu dans une mémoire
    for (i in seq_along(permutation)) {
      jeu <- permutation[i]
      fitted <- FALSE
      for (j in seq_along(bins)) {
        if (sum(bins[[j]]) + jeu <= taille_memoire) {
          bins[[j]] <- c(bins[[j]], jeu)
          memoires[j] <- memoires[j] - jeu
          fitted <- TRUE
          break
        }
      }

      if (!fitted) {
        bins <- c(bins, list(jeu))
        memoires <- c(memoires, taille_memoire - jeu)
        nombre_memoires <- nombre_memoires + 1
      }
    }

    # Calculer le nombre de mémoires utilisées
    nombre_memoires <- sum(taille_memoire - memoires > 0)

    # Mettre à jour le nombre minimal de mémoires nécessaires
    if (nombre_memoires < memoire_minimale){
      memoire_minimale <- nombre_memoires
      best_bins <- bins
    }

  }

  # Créer une liste pour stocker les jeux dans chaque stockage
  jeux_dans_stockages <- list()
  for (bin in best_bins) {
    jeux_dans_stockages <- c(jeux_dans_stockages, list(bin))
  }

  return(list(memoire_minimale = memoire_minimale, jeux_dans_stockages = jeux_dans_stockages))
}

```

```{r}
jeux <- sample(1:1000, size=4)
taille_memoire <- 1000
resultat_exact <- memoire_exact(jeux, taille_memoire)
print(paste("Nombre minimal de mémoire nécessaire :", resultat_exact))
resultat_exact$jeux_dans_stockages
```

```{r}
res = c()
for (i in 1:11){
  jeux <- sample(1:1000, size=i)
  temps = system.time({naive_storage_Rcpp(jeux, taille_memoire)})['elapsed']
  res = c(res, temps)
}

res
```

```{r}
plot(c(1:11), res, main="Temps d'éxécution pour la fonction naive_storage_Rcpp", col = "blue", pch = 19, cex = .6)
```

## Branch and bound


```{r}
bfd <- function(jeux, m) {
  n <- length(jeux)
  stockages <- list()
  for (i in 1:n) {
    if (length(stockages) == 0) {
      stockages[length(stockages) + 1] <- list(jeux[i])
      next
    }
    best_bin <- 0
    best_fit <- Inf
    for (j in 1:length(stockages)) {
      if (jeux[i] <= m - sum(unlist(stockages[[j]])) && sum(unlist(stockages[[j]])) < best_fit) {
        best_fit <- sum(unlist(stockages[[j]]))
        best_bin <- j
      }
    }
    if (best_fit == Inf) {
      stockages[length(stockages) + 1] <- list(jeux[i])
    } else {
      stockages[[best_bin]] <- c(stockages[[best_bin]], jeux[i])
    }
  }
  return(stockages)
}


# Fonction pour appliquer l'algorithme de Branch and Bound
branch_and_bound <- function(jeux, m) {
  n <- length(jeux)
  jeux <- sort(jeux, decreasing = TRUE)
  best_sol <- n
  bfd_sol <- length(bfd(jeux, m))
  if (bfd_sol < best_sol) {
    best_sol <- bfd_sol
  }
  stack <- list()
  stack[[1]] <- list(level = 0, items = jeux, bins = numeric(n), num_bins = 0, bound = borne_inf(jeux, m))
  while (length(stack) > 0) {
  
    node <- stack[[length(stack)]]
    stack <- stack[-length(stack)]
    if (node$bound >= best_sol) {
      next
    }
    if (node$num_bins + node$bound >= best_sol) {
      next
    }
    if (node$num_bins + node$bound < best_sol) {
      best_sol <- node$num_bins + node$bound
    }
    if (length(node$items) == 0) {
      next
    }
    new_bins <- node$bins
    new_num_bins <- node$num_bins
    for (i in 1:length(node$items)) {
      new_bins[i] <- new_bins[i] + node$items[1]
      new_num_bins <- new_num_bins + 1
      if (new_num_bins + borne_inf(node$items[-1], m) >= best_sol) {
        new_bins[i] <- new_bins[i] - node$items[1]
        new_num_bins <- new_num_bins - 1
        break
      }
      new_items <- node$items[-1]
      new_bound <- borne_inf(new_items, m)
      new_node <- list(level = node$level + 1, items = new_items, bins = new_bins, num_bins = new_num_bins, bound = new_bound)
      stack <- c(stack, list(new_node))
      new_bins[i] <- new_bins[i] - node$items[1]
      new_num_bins <- new_num_bins - 1
    }
  }
  return(best_sol)
}
```



```{r}
branch_and_bound <- function(jeux, m) {
  n <- length(jeux)
  jeux <- sort(jeux, decreasing = TRUE)
  best_sol <- n
  tree <- list(level = list(node = c(), bins = list()), unexp_items = jeux, bound = borne_inf(jeux, m))
  while (length(tree$unexp_items) > 0) {
    node <- stack[[length(stack)]]
    stack <- stack[-length(stack)]
    if (node$bound >= best_sol) {
      print('here')
      next
    }
    if (node$num_bins + node$bound >= best_sol) {
      print('la')
      next
    }
    if (node$num_bins + node$bound < best_sol) {
      best_sol <- node$num_bins + node$bound
    }
    if (length(node$items) == 0) {
      print('ici')
      next
    }
    # Exécuter l'algorithme BFD
    bfd_node <- bfd(node$items, m)
    if (length(bfd_node) < best_sol) {
      best_sol <- length(bfd_node)
    }
    new_bins <- node$bins
    new_num_bins <- node$num_bins
    for (i in 1:length(node$items)) {
      new_bins[i] <- new_bins[i] + node$items[1]
      new_num_bins <- new_num_bins + 1
      new_items <- node$items[-1]
      new_bound <- borne_inf(new_items, m)
      if (new_num_bins + borne_inf(node$items[-1], m) >= best_sol) {
        new_bins[i] <- new_bins[i] - node$items[1]
        new_num_bins <- new_num_bins - 1
        next
      }
      
      new_node <- list(level = node$level + 1, items = new_items, bins = new_bins, num_bins = new_num_bins, bound = new_bound)
      stack <- c(stack, list(new_node))
      cat('stack 3 : ')
      print(stack)
      new_bins[i] <- new_bins[i] - node$items[1]
      new_num_bins <- new_num_bins - 1
    }
  }
  return(best_sol)
}

```

```{r}
branch_and_bound <- function(jeux, m) {
  n <- length(jeux)
  jeux <- sort(jeux, decreasing = TRUE)
  best_sol <- n
  bfd_sol <- length(bfd(jeux, m))
  if (bfd_sol < best_sol) {
    best_sol <- bfd_sol
  }
  stack <- list()
  stack[[1]] <- list(level = 0, items = jeux, bins = numeric(n), num_bins = 0, bound = borne_inf(jeux, m))
  while (length(stack) > 0) {
    node <- stack[[length(stack)]]
    stack <- stack[-length(stack)]
    
    if (length(node$items) == 0) {
      next
    }
    # Exécuter l'algorithme BFD
    bfd_node <- bfd(node$items, m)
    if (length(bfd_node) < best_sol) {
      best_sol <- length(bfd_node)
    }
    new_bins <- node$bins
    new_num_bins <- node$num_bins
    for (i in 1:length(node$items)) {
      new_bins[i] <- new_bins[i] + node$items[1]
      new_num_bins <- new_num_bins + 1
      if (new_num_bins + borne_inf(node$items[-1], m) >= best_sol) {
        new_bins[i] <- new_bins[i] - node$items[1]
        new_num_bins <- new_num_bins - 1
        break
      }
      new_items <- node$items[-1]
      new_bound <- borne_inf(new_items, m)
      new_node <- list(level = node$level + 1, items = new_items, bins = new_bins, num_bins = new_num_bins, bound = new_bound)
      stack <- c(stack, list(new_node))
      new_bins[i] <- new_bins[i] - node$items[1]
      new_num_bins <- new_num_bins - 1
      
      if (node$bound >= best_sol) {
      next
    }
      if (node$num_bins + node$bound >= best_sol) {
      next
    }
      if (node$num_bins + node$bound < best_sol) {
      best_sol <- node$num_bins + node$bound
    }
    }
  }
  return(best_sol)
}



bfd <- function(jeux, m) {
  n <- length(jeux)
  stockages <- list()
  for (i in 1:n) {
    if (length(stockages) == 0) {
      stockages[length(stockages) + 1] <- list(jeux[i])
      next
    }
    best_bin <- 0
    best_fit <- Inf
    for (j in 1:length(stockages)) {
      if (jeux[i] <= m - sum(unlist(stockages[[j]])) && sum(unlist(stockages[[j]])) < best_fit) {
        best_fit <- sum(unlist(stockages[[j]]))
        best_bin <- j
      }
    }
    if (best_fit == Inf) {
      stockages[length(stockages) + 1] <- list(jeux[i])
    } else {
      stockages[[best_bin]] <- c(stockages[[best_bin]], jeux[i])
    }
  }
  return(stockages)
}


```




```{r}
jeux <- sample(1:10, size=6, replace = TRUE)
taille_memoire <- 10
result <- branch_and_bound(jeux, taille_memoire)
print(result)

resultat_exact <- naive_storage_Rcpp(jeux, taille_memoire)
print(resultat_exact$memoire_minimale)
```

```{r}
res = c()
for(i in seq(1, 20, 1)){
  jeux <- sample(1:1000, size=i, replace = TRUE)
  temps = system.time({naive_storage_Rcpp(jeux, taille_memoire)})['elapsed']
  res = c(res, temps)
}
```

```{r}
plot(seq(1, 20, 1), res, main="Temps d'éxécution pour la fonction naive_storage_Rcpp", col = "blue", pch = 19, cex = .6)

```
