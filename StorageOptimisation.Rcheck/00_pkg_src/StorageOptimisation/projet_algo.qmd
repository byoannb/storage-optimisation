---
title: "projet_algo"
format: html
editor: visual
---

```{r}
mem = sample(100:1000, size=5, replace=TRUE)
l = sample(1:100, size=25, replace=TRUE)
jeux = sort(l, decreasing = TRUE)
mem = sort(mem, decreasing = TRUE)

mat = matrix(0, nrow = length(mem), ncol = length(jeux))

print(jeux)
cat('\n')
print(mem)
```

```{r}
storage_opti <- function(storages, games){
  
  games = sort(games, decreasing = TRUE)
  storages = sort(storages, decreasing = TRUE)
  
  i_mem = 1
  j_jeu = 1
  mat = matrix(0, nrow = length(storages), ncol = length(games))
  colnames(mat) = games
  rownames(mat) = storages
  
  while(length(games) != 0 && i_mem <= length(storages) && j_jeu <= length(games)){
    if (storages[i_mem] - games[j_jeu] >= 0){
        storages[i_mem] = storages[i_mem] - games[j_jeu]
        mat[i_mem, j_jeu] = 1
        j_jeu = j_jeu + 1
    }
    else {
      i_mem = i_mem + 1
    }
  }
  cat(sum(rowSums(mat) != 0), "out of", length(storages), "storage facilities were used \n")
  cat(sum(colSums(mat)), "out of", length(games), "games could be stored")
  return(mat)
}
```

```{r}
mem = sample(1:5000, size=3, replace=FALSE)
jeux = sample(1:100, size=10, replace=TRUE)
```

```{r}
algo <- function(mem, jeux){
  p = length(mem)
  n = length(jeux)
  
  max = 0
  vect_max = c()
  vect <- as.matrix(expand.grid(rep(list(0:p), n)))
  mat = matrix(0, nrow = p, ncol = n)
  
  mem_count = matrix(0, ncol = p)
  
  for (j in 1:dim(vect)[1]){
    for (i in 1:length(vect[j,])) {
      if (vect[j,i] == 0){
        next
      }
      else{
        mat[vect[j,i], i] <- 1
        mem_count[vect[j,i]] = mem_count[vect[j,i]] + jeux[i]
      }
    }
    if (all(mem_count <= mem)){
      if (sum(rowSums(mat)) > max){
        vect_max = vect[j,]
        max = sum(rowSums(mat))
      }
    }
  }
  
  return(list(max=max, vect_max=vect_max))
}

algo(mem, jeux)
```

# Version 2

```{r}
memoire_exact <- function(jeux, taille_memoire) {
  # Fonction pour générer toutes les permutations
  generate_permutations <- function(elements) {
    if (length(elements) <= 1) {
      return(list(elements))
    } else {
      perms <- list()
      for (i in 1:length(elements)) {
        current_element <- elements[i]
        remaining_elements <- elements[-i]
        sub_perms <- generate_permutations(remaining_elements)
        for (perm in sub_perms) {
          perms <- c(perms, list(c(current_element, perm)))
        }
      }
      return(perms)
    }
  }
  
  # Générer toutes les permutations possibles des jeux
  permutations <- generate_permutations(jeux)
  
  memoire_minimale <- Inf  # Initialisation à une valeur infinie
  
  # Pour chaque permutation
  for (permutation in permutations) {
    memoires <- rep(taille_memoire, length(jeux))  # Initialise toutes les mémoires avec la même taille
    nombre_memoires <- 0
    
    # Essayer de placer chaque jeu dans une mémoire
    for (jeu in permutation) {
      for (i in 1:length(memoires)) {
        if (jeu <= memoires[i]) {
          memoires[i] <- memoires[i] - jeu
          break
        }
      }
    }
    
    # Calculer le nombre de mémoires utilisées
    nombre_memoires <- sum(taille_memoire - memoires > 0)
    
    # Mettre à jour le nombre minimal de mémoires nécessaires
    memoire_minimale <- min(memoire_minimale, nombre_memoires)
  }
  
  return(memoire_minimale)
}
```

```{r}
jeux <- sample(1:1000, size=5)
taille_memoire <- 1000
resultat_exact <- memoire_exact(jeux, taille_memoire)
print(paste("Nombre minimal de mémoire nécessaire :", resultat_exact))

```

```{r}
res = c()
for (i in 1:11){
  jeux <- sample(1:1000, size=i)
  temps = system.time({naive_storage_Rcpp(jeux, taille_memoire)})['elapsed']
  res = c(res, temps)
}

res
```

```{r}
plot(c(1:11), res, main="Temps d'éxécution pour la fonction naive_storage_Rcpp", col = "blue", pch = 19, cex = .6)
```

## Branch and bound

```{r}
# Fonction pour calculer la borne inférieure L1
borne_inf <- function(jeux, m) {
  return(ceiling(sum(jeux) / m))
}

# Fonction pour appliquer la stratégie Best-Fit Decreasing (BFD)
# Fonction pour appliquer la stratégie Best-Fit Decreasing (BFD)
bfd <- function(jeux, m) {
  n <- length(jeux)
  stockages <- numeric(n)
  num_stockages <- 0
  for (i in 1:n) {
    if (num_stockages == 0) {
      stockages[num_stockages + 1] <- jeux[i]
      num_stockages <- num_stockages + 1
      next
    }
    best_bin <- 0
    best_fit <- Inf
    for (j in 1:num_stockages) {
      if (jeux[i] <= m - stockages[j] && stockages[j] < best_fit) {
        best_fit <- stockages[j]
        best_bin <- j
      }
    }
    if (best_fit == Inf) {
      stockages[num_stockages + 1] <- jeux[i]
      num_stockages <- num_stockages + 1
    } else {
      stockages[best_bin] <- stockages[best_bin] + jeux[i]
    }
  }
  return(num_stockages)
}

# Fonction pour appliquer l'algorithme de Branch and Bound
branch_and_bound <- function(jeux, m) {
  n <- length(jeux)
  jeux <- sort(jeux, decreasing = TRUE)
  best_sol <- n
  bfd_sol <- bfd(jeux, m)
  if (bfd_sol < best_sol) {
    best_sol <- bfd_sol
  }
  stack <- list()
  stack[[1]] <- list(level = 0, items = jeux, bins = numeric(n), num_bins = 0, bound = borne_inf(jeux, m))
  while (length(stack) > 0) {
    node <- stack[[length(stack)]]
    stack <- stack[-length(stack)]
    if (node$bound >= best_sol) {
      next
    }
    if (node$num_bins + node$bound >= best_sol) {
      next
    }
    if (node$num_bins + node$bound < best_sol) {
      best_sol <- node$num_bins + node$bound
    }
    if (length(node$items) == 0) {
      next
    }
    new_bins <- node$bins
    new_num_bins <- node$num_bins
    for (i in 1:length(node$items)) {
      new_bins[i] <- new_bins[i] + node$items[1]
      new_num_bins <- new_num_bins + 1
      if (new_num_bins + borne_inf(node$items[-1], m) >= best_sol) {
        new_bins[i] <- new_bins[i] - node$items[1]
        new_num_bins <- new_num_bins - 1
        break
      }
      new_items <- node$items[-1]
      new_bound <- borne_inf(new_items, m)
      new_node <- list(level = node$level + 1, items = new_items, bins = new_bins, num_bins = new_num_bins, bound = new_bound)
      stack <- c(stack, list(new_node))
      new_bins[i] <- new_bins[i] - node$items[1]
      new_num_bins <- new_num_bins - 1
    }
  }
  return(best_sol)
}


```


```{r}
jeux <- sample(1:1000, size=1000)
taille_memoire <- 1000
result <- branch_and_bound(jeux, taille_memoire)
print(result)



resultat_exact <- memoire_exact(jeux, taille_memoire)
print(resultat_exact)
```


```{r}
res = c()
for(i in seq(1, 5000, 500)){
  jeux <- sample(1:1000, size=i, replace = TRUE)
  temps = system.time({branch_and_bound(jeux, taille_memoire)})['elapsed']
  res = c(res, temps)
}
```


```{r}
plot(seq(1, 5000, 500), res, main="Temps d'éxécution pour la fonction naive_storage_Rcpp", col = "blue", pch = 19, cex = .6)

```

